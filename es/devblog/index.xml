<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Devblog on Dangling Pointr</title>
    <link>https://pedro-javierf.github.io/es/devblog/</link>
    <description>Recent content in Devblog on Dangling Pointr</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 11 Oct 2020 11:39:11 +0200</lastBuildDate>
    
	<atom:link href="https://pedro-javierf.github.io/es/devblog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Solución reto rhme fiesta del Riscure Hardware CTF 2016 con EM Fault Injection</title>
      <link>https://pedro-javierf.github.io/es/devblog/rhmefaultinjection/</link>
      <pubDate>Sun, 11 Oct 2020 11:39:11 +0200</pubDate>
      
      <guid>https://pedro-javierf.github.io/es/devblog/rhmefaultinjection/</guid>
      <description>Abstract Vamos a ver como solucionar el reto Fiesta del Riscure Embedded Hardware CTF edición 2016 utilizando un método nuevo, Fault Injection electromagnético.
El reto tiene una historia detrás, y está específicamente diseñado para solucionarse a través de Fault Injection
Herramientas Para solucionar el reto utilizaré únicamente mi inyector de fallos EM.
Reto y Solución Cargamos el ejecutable .hex en un arduino Nano, y al observar la salida serial (19200 baudios) descubrimos que el dispositivo está bloqueado:</description>
    </item>
    
    <item>
      <title>Electromagnetic Fault Injection por dos duros</title>
      <link>https://pedro-javierf.github.io/es/devblog/faultinjectionpordosduros/</link>
      <pubDate>Fri, 09 Oct 2020 11:39:11 +0200</pubDate>
      
      <guid>https://pedro-javierf.github.io/es/devblog/faultinjectionpordosduros/</guid>
      <description>Abstract En la entrada que hoy nos concierne, vamos a ver como fabricar un dispositivo capaz de realizar EM Fault Injection por menos de 5€.
¿Qué es Fault Injection? Fault Injection, o en español,inyección de fallos (vaya nombre feo) es un término ampliamente utilizado en el mundo del hardware y de la seguridad informática. Consiste en introducir errores lógicos en las CPUs mediante la alteración del hardware. Esto permite que, aunque un procesador esté ejecutando un código 100% seguro y libre de fallos, podamos causarlos nosotros, extrayendo secretos o redirigiendo la ejecución a nuestro propio software no autorizado, entre otros escenarios.</description>
    </item>
    
    <item>
      <title>Loader Avanzado en Ghidra: labels, overlays y Function ID</title>
      <link>https://pedro-javierf.github.io/es/devblog/advancedghidraloader/</link>
      <pubDate>Sun, 24 May 2020 12:30:38 +0200</pubDate>
      
      <guid>https://pedro-javierf.github.io/es/devblog/advancedghidraloader/</guid>
      <description>Antecedentes El mes pasado hablábamos sobre los conceptos básicos de un Loader para Ghidra. Esta vez cubriré algunas características adicionales para mejorar nuestra extensión y hacerla más útil y manejable.
Veremos estas nuevas características en orden ascendente de complejidad.
Labels Muchas veces, cuando tratamos con sistemas embebidos, encontramos arquitecturas que son &amp;ldquo;simples&amp;rdquo; conceptualmente. Las medidas de seguridad son pocas, y el código de un programa suele compilarse de forma estática, y se carga siempre en la misma dirección de memoria.</description>
    </item>
    
    <item>
      <title>Tutorial: Escribir un loader para Ghidra</title>
      <link>https://pedro-javierf.github.io/es/devblog/tutorialwritingaghidraloader/</link>
      <pubDate>Mon, 06 Apr 2020 12:30:38 +0200</pubDate>
      
      <guid>https://pedro-javierf.github.io/es/devblog/tutorialwritingaghidraloader/</guid>
      <description>Introducción ¡Todos a bordo del tren del reversing! Abril de 2020 y el mundo entero parece haberse detenido debido al covid-19. Yo mismo me encuentro en cuarentena estos días, lo cual dentro de lo malo es una buena oportunidad para seguir aprendiendo. Llevo un tiempo dedicando mi esfuerzo en mejorar mi conocimiento de herramientas libres de ingeniería inversa (reversing) y dejar a un lado el software de pago, asi que decidí que sería una idea excelente aprender más sobre Ghidra y su funcionamiento.</description>
    </item>
    
    <item>
      <title>Hackeando Ikariam: Cross Site Scripting (xss) persistente y &#39;weaponización&#39;</title>
      <link>https://pedro-javierf.github.io/es/devblog/ikariamexploit/</link>
      <pubDate>Fri, 15 Nov 2019 19:35:38 +0200</pubDate>
      
      <guid>https://pedro-javierf.github.io/es/devblog/ikariamexploit/</guid>
      <description>Introducción ⚠  TODO EL CONTENIDO SE PROPORCIONA &amp;ldquo;COMO ESTÁ&amp;rdquo;, SIN GARANTÍA DE NINGÚN TIPO, EXPRESA O IMPLÍCITA, INCLUYENDO PERO NO LIMITADO A GARANTÍAS DE COMERCIALIZACIÓN, IDONEIDAD PARA UN PROPÓSITO PARTICULAR E INCUMPLIMIENTO. EN NINGÚN CASO LOS AUTORES O PROPIETARIOS DE LOS DERECHOS DE AUTOR SERÁN RESPONSABLES DE NINGUNA RECLAMACIÓN, DAÑOS U OTRAS RESPONSABILIDADES, YA SEA EN UNA ACCIÓN DE CONTRATO, AGRAVIO O CUALQUIER OTRO MOTIVO, DERIVADAS DE EL CONTENIDO O SU USO U OTRO TIPO DE ACCIONES EN EL CONTENIDO.</description>
    </item>
    
    <item>
      <title>Hacking The 3ds IV: Ataques Hardware</title>
      <link>https://pedro-javierf.github.io/es/devblog/hacking3ds4/</link>
      <pubDate>Thu, 25 Jul 2019 19:35:38 +0200</pubDate>
      
      <guid>https://pedro-javierf.github.io/es/devblog/hacking3ds4/</guid>
      <description>Introducción En este post vamos a introducirnos de lleno en el mundo de los ataques a nivel de hardware, especificamente orientados a la 3ds pero totalmente aplicables a otros dispositivos. He descrito todo con el máximo nivel de detalle posible, intentando explicar conceptos previos. Espero que sea de utilidad, y además, que sirva para preservar del olvido algunos increibles ataques que la pequeña consola de Nintendo ha visto.
Ataques Hardware Hace unos años, cuando escribí mi primer artículo sobre hacking de la 3ds, pensaba que los ataques en el hardware pertenecían a ese tipo de habilidades mágicas que son imposibles de aprender si no has nacido con ellas.</description>
    </item>
    
    <item>
      <title>Hacking The 3ds III: Análisis de memoria</title>
      <link>https://pedro-javierf.github.io/es/devblog/hacking3ds3/</link>
      <pubDate>Wed, 30 Jan 2019 19:35:38 +0200</pubDate>
      
      <guid>https://pedro-javierf.github.io/es/devblog/hacking3ds3/</guid>
      <description>Introduccción Bienvenidos de nuevo. Finalmente, es hora de continuar hackeando la Nintendo 3DS. Anteriormente tratamos volcados de memoria donde pudimos encontrar cadenas de texto y otros contenidos, confirmando que los datos no estaban cifrados.
Identificando el código A pesar de haber utilizado binvis y haber podido observar diferencias claras entre datos y código, no fue una herramienta suficientemente precisa para continuar. Antes de hacer nada más, intenté jugar todas mis bazas y analizar los volcados con cualquier programa que fuese posible.</description>
    </item>
    
    <item>
      <title>Hacking The 3ds II: Encontrando el Patrón</title>
      <link>https://pedro-javierf.github.io/es/devblog/hacking3ds2/</link>
      <pubDate>Tue, 30 Jan 2018 11:30:48 +0200</pubDate>
      
      <guid>https://pedro-javierf.github.io/es/devblog/hacking3ds2/</guid>
      <description>Bienvenidos de nuevo! Estamos de vuelta en esta parte 2 &amp;ldquo;Encontrando el Patrón&amp;rdquo; si aun no has leido la parte 1&amp;hellip; ¡échale un vistazo ahora!
Resumen Rápido Anteriormente, había analizado que posibles puntos de entrada podría utilizar para conocer más sobre la Nintendo 3DS. La conclusión fue que, al parecer, los contenidos de la memoria RAM no estaban encriptados. Podéis verlo aquí:
 Ejemplo de cadena de texto UNICODE que se encuentra en los volcados de memoria RAM</description>
    </item>
    
    <item>
      <title>Hacking The 3ds I: Introducción</title>
      <link>https://pedro-javierf.github.io/es/devblog/hacking3ds1/</link>
      <pubDate>Mon, 12 Jun 2017 11:17:57 +0200</pubDate>
      
      <guid>https://pedro-javierf.github.io/es/devblog/hacking3ds1/</guid>
      <description>Bienvenido a una nueva serie de entradas del blog! En esta ocasión recorreré un largo camino hasta conseguir hackear las consolas de la familia Nintendo 3DS. Hay varias razones de ser de estos posts:
 Interés personal: Cuándo la scene de 3ds empezó a crecer en 2014, yo estaba allí, y tengo ganas de aprender todo lo que no pude en su momento. Comunidad Tóxica: Durante muchos años la comunidad se ha centrado solo en la pirateria y los resultados finales; poca gente estaba interesada en aprender La falta de información en internet sobre ingeniería inversa y hacking de sistemas &amp;ldquo;black box&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Hackeando la 3ds 0: Recursos</title>
      <link>https://pedro-javierf.github.io/es/devblog/hacking3ds0/</link>
      <pubDate>Thu, 01 Jun 2017 20:49:36 +0200</pubDate>
      
      <guid>https://pedro-javierf.github.io/es/devblog/hacking3ds0/</guid>
      <description>¿De qué va esto? Esta página contiene recursos adicionales de gran valor relacionados con mis artículos sobre el hacking de la Nintendo 3DS. Incluyendo, pero no solo, herramientas, artículos externos, posts de stack overflow, y cualquier otro recurso que sea de utilidad.
 ADVERTENCIA: La mayoría de estos recursos se encuentran en inglés.
 URLs / Artículos booting-process-for-arm
ARM Reset vector information
ARM Image Entrypoint Docs
ARM Boot procedure</description>
    </item>
    
  </channel>
</rss>