<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Introducción al desarrollo de exploits en ARM</title>

		<meta name="description" content="Introducción al desarrollo de exploits en ARM para c1b3rwall academy 2020">
		<meta name="author" content="pedro-javierf">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-background="res/coding.gif" data-background-opacity="10%">
					<h3>Introducción al desarrollo de exploits en ARM</h3>
					<a>
						<img src="res/armlogo.jpg" alt="arm logo" style="height: 180px; margin: 0 auto 4rem auto; background: transparent;" class="demo-logo">
					</a>
					<p>
						<small>C1b3rWall Academy 2020</small> <br>
						<small>Pedro Javier Fernández (<a href="https://github.com/pedro-javierf">pedro-javierf</a>)</small>
					</p>
				</section>


				<section data-transition="slide" data-background="#120066" data-background-transition="zoom">
					<h3>Pedro Javier Fernández</h3>
					<small>pedro-javierf</small>
					<br><br>
					<ul>
						<span class="fragment"><li>Reversing, exploiting, programación, ...</li></span>
						<span class="fragment"><li>Secretario @ LibreLabUCM.</li></span>
						<span class="fragment"><li>Devblog hacking:</li></span>
					</ul>
					<br>
					<img src="res/avatar.png" width="150" height="150">
					<img src="https://librelabucm.org/images/logos/llu-logo-large-square-trans_11.png" width="150" height="150">
					  
				</section>

				<section data-transition="slide" data-background="#120066" data-background-transition="zoom">
					<h3>Diapositivas</h3>
					Disponibles en:<br><br>

					https://pedro-javierf.github.io/es/talks/c1b3rwall2020
					
					  
				</section>

				<section data-transition="slide" data-background="#120066" data-background-transition="zoom">
					<h3>Conocimientos previos (recomendados)</h3>
					<ul>
						<span class="fragment"><li>Lenguaje C o C++</li></span>
						<span class="fragment"><li>Conocimientos básicos computación (notación hexadecimal, etc)</li></span>
						<span class="fragment"><li>Ganas de aprender.</li></span>
					</ul>
					  
				</section>

				<section data-transition="slide" data-background="#120066" data-background-transition="zoom">
					<h3>exploit</h3>

						<span class="fragment">Técnica o programa que abusa una vulnerabilidad en un sistema.</span>


					  
				</section>

				<!-- Example of nested vertical slides -->
				<section data-transition="slide" data-background="#120066">
					<section>
						<h2>Motivación</h2>
						<p>¿Por qué es interesante conocer sobre la arquitectura <em>ARM</em>?</p>
						<p>Hay varias razones de peso:</p>
						<br>
						<a href="#" class="navigate-down">
							<img style="background: rgba(255,255,255,0.1);" width="178" height="238" data-src="res/down-arrow.svg" alt="Down arrow">
						</a>
					</section>
					<section>
						<h2>Smartphones</h2>

						<div style="position:relative; width:640px; height:480px; margin:0 auto;">
							<img class="fragment fade-out" data-fragment-index="0"  src="res/smartphone.jpg" style="position:absolute;top:0;left:0;" />
							<img class="fragment fade-in" data-fragment-index="0"  src="res/iphone.jpg" style="position:absolute;top:0;left:0;" />
						</div>

					</section>
					<section>
						<h2>Otros muchos dispositivos...</h2>
						<p>Muchos, muchos dispositivos:</p>
						<br>
						
						<div style="position:relative; width:300px; height:280px; margin:0 auto;">
							<img class="fragment fade-in-then-out" data-fragment-index="0"  src="res/tv.jpg" style="position:absolute;top:0;left:0;" />
							<img class="fragment fade-in-then-out" data-fragment-index="1"  src="res/switch.png" style="position:absolute;top:0;left:0;" />
							<img class="fragment fade-in-then-out" data-fragment-index="2"  src="res/fpga1.jpg" style="position:absolute;top:0;left:0;" />
							<img class="fragment fade-in-then-out" data-fragment-index="3"  src="res/raspi.png" style="position:absolute;top:0;left:0;" />
							<img class="fragment fade-in-then-out" data-fragment-index="4"  src="res/router.png" style="position:absolute;top:0;left:0;" />
							<img class="fragment fade-in" data-fragment-index="5"  src="res/hp-envy-x2.jpg"  style="position:absolute;top:0;left:0;" />
						</div>

					</section>
				</section>

				<section data-transition="slide" data-background="#120066">
					<h2>Contenidos</h2>
					<ul>
						<span class="fragment"><li>Conceptos básicos de la arquitectura ARM.</li></span>
						<span class="fragment"><li>Conceptos básicos sobre la memoria y el curso de ejecución de los programas.</li></span>
						<span class="fragment"><li>Breve introducción a nuestros "sistemas de pruebas".</li></span>
						<span class="fragment"><li>Stack Buffer Overflow (no NX)</li></span>
						<span class="fragment">
							<ul>
								<li>teoría</li>
								<li>ejemplo práctico (reproducible)</li>
							</ul></span>
						<span class="fragment"><li>Mitigación NX bit y cómo superarla</li></span>
						<span class="fragment"><li>Mitigación ASLR y cómo superarla</li></span>

					</ul>
				</section>

				<!-- more nested slides -->
				<section data-auto-animate data-transition="slide" data-background="#120066">
					<h2 data-id="code-title">1. Conceptos Básicos</h2>
					
					<section>
					<ul>
						<span class="fragment"><li>El Stack.</li></span>
						<span class="fragment"><li>Registros.</li></span>
						<span class="fragment"><li>Subrutinas.</li></span>
					</ul>
					</section>

					<section>
						<br>
						<h2 data-id="code-title">1.1 El Stack o pila</h2>
						<img class="stretch" src="res/stack_pop_operation.jpg">
					
					</section>

					<section>
						<br>
						<h3 data-id="code-title">1.2 Registros</h2>
							Existen 16* registros de 32bits (4 bytes) disponibles para el programador. 
						<table>
							<thead>
								<tr>
									<th>Nombre</th>
									<th>Propósito</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>r0 - r11</td>
									<td>Propósito General</td>
								</tr>
								<tr>
									<td>r12 o IP</td>
									<td>IPC</td>
								</tr>
								<tr>
									<td>r13 o SP</td>
									<td>Stack Pointer</td>
								</tr>
								<tr>
									<td>r14 o LR</td>
									<td>Link Register</td>
								</tr>
								<tr>
									<td>r15 o PC</td>
									<td>Program Counter</td>
								</tr>
							</tbody>
						</table>
						</section>

						<section data-transition-speed="slow" data-transition="fade-right" style="text-align: left;">
							<small>Ejemplo 1: copiamos el número 7 al registro r4.</small>
							<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers>
								mov     r4, #7
							</code>
							</pre>
							
							<small>Ejemplo 2: Sumamos 3 a el valor de r4 (7).</small>
							<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers>
								add     r4, r4, #3
							</code>
							</pre>
						</section>

						<section>
							<h3 data-id="code-title">1.2 Subrutinas</h2>
								"Piezas" de código que podemos reutilizar cuantas veces queramos. (Otros nombres: funciones, procedimientos, e incluso métodos).
								<br><br>
								<small>Existen 2 tipos:<br>
									<ul>
										<li>Subrutinas simples</li>
										<li>Subrutinas que llaman a otras subrutinas</li>
									</ul>
								</small>
						</section>


						<section>
							<h3 data-id="code-title">1.3 Subrutinas</h2>
								
								
								Ejemplo 1: subrutina simple<br>
								<p style="text-align: left;">
								<small>Código Principal:</small></p>
								<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers>
									_main: //2000000
									mov r0, r7
									bl _IncrementRegister0 //Llamada a la subrut.
									mov r7, r0
								</code></pre>

								<p style="text-align: left;">
								<small>Subrutina:</small></p>
								<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers>
									_IncrementRegister0: //20064f0
									add r0, r0, #1
									bx lr //Vuelve a la dirección indicada por lr
								</code></pre>
							
						</section>

						<section>
							<h3 data-id="code-title">1.2 Subrutinas</h2>
								<small>La siguiente instrucción:</small>
								<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers>
									bl      _IncrementRegister0   @Llamamos a la subrutina
								</code></pre>
								<small>
									De forma invisible al programador, esta instrucción hace 2 cosas:
								
									<ol>
										<li>Guarda la dirección a la que hay que volver después de ejecutar la subrutina. Concretamente en el registro LR. </li>
										<br>
										<li>Cambia el valor del registro PC a la dirección de la subrutina. Supongamos que _IncrementRegister0 se encuentra en la dirección de memoria 0x02000A00. Entonces el nuevo valor del PC será 0x02000A00 y allí es dónde continuará la ejecución.</li>
										<br>
									<ol>
										<p class="fragment highlight-red" data-fragment-index="2" >La rutina se encarga al terminar de ejecutar otra instrucción: (bx lr), que restaurará en el PC el valor que haya en ese momento en LR. Es decir:
											PC = LR </p>
										 
								
								</small>
						</section>


						<section>
							<br>
								Ejemplo 2: subrutina que utiliza otras subrutinas
								<p style="text-align: left;">
								<small>Código Principal:</small></p>
								<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers>
									_main: @ 2000000

									mov r0, r7
									bl _PrintText @Llamada a la subrut.
									mov r7, r0
								</code></pre>

								<p style="text-align: left;">
								<small>Subrutina:</small></p>
								<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers>
									_PrintText: @ 20064f0

									push {lr}
									mov r1, #0
									bl _PrintCharacter @Llama a otra subrutina
									...
									pop {pc}
								</code></pre>
							
						</section>

						<section>
							<img class="stretch" src="res/stack_pop_operation.jpg"><br>
						
						</section>

						<!--
						<section>
							<h3 data-id="code-title">1.2 Subrutinas</h2>
								<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers>
									push    {r5,lr}	        @Guardamos el LR
									mov     r0, #1          @Copiamos el num. 1 a r0
									mov 	r5, #0          @Otro parámetro para ErrorHandling
									bl      ErrorHandling   @Llamamos a la subrutina
									str     r0, #0xC1B30000 @Recogemos el resultado de la subrut.
									pop     {r5,pc}	        @Restauramos el LR en el PC
								</code></pre>
						</section>-->



						

				</section>

				
				<!--
				<section data-auto-animate data-transition="slide" data-background="#120066">
					<h2 data-id="code-title">Ensamblador ARM</h2>
					<small>Juntamos todas las piezas...</small>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers>
						push    {r4,lr}          @Algunas tareas previas..
						mov     r4, r0
						ldr     r0, [r4, #0x4]
						bl      ErrorHandling    @Salta a la subrutina.
						ldr     r1, [r4, #0x0]   @La subrutina termina y la CPU vuelve aquí. Ejecuta esta instrucción 
						mov     r0, #0x0         @Y después esta...
						...
					</code></pre>
					<p>Fragmento de código de una rutina del videojuego <a href="https://github.com/JimB16/PokePlat/blob/master/source/arm9_Overlay.s/">Pokémon Platino</a>.</p>
				</section>-->

				<section data-auto-animate data-transition="fade" data-background="#120066">
					<h3 data-id="code-title">2. Vulnerabilidades de memoria + curso de ejecución</h3>

					<section>
						<small>
						¿De qué forma podría un atacante redireccionar el orden de ejecución de un programa para direccionarlo a su código malicoso?
					</small>
					<p class="fragment highlight-red" data-fragment-index="2" >El objetivo final es que el valor de una dirección de memoria donde tengamos nuestro código "malicioso", acabe en el registro PC.</p>
					</section>

					
				</section>

				<section data-auto-animate data-transition="fade" data-background="#120066">
					<h3 data-id="code-title">2. Vulnerabilidades de memoria + curso de ejecución</h3>

					<small>Como vimos anteriormente: </small>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers>
						_PrintText: @ 20064f0

						push {lr}
						mov r1, #0
						bl _PrintCharacter @Llama a otra subrutina
						...
						pop {pc}  
					</code></pre>
					pop {pc} extrae el valor en la cima del STACK y lo guarda en PC<br>
					<span class="fragment">
					<small>Si logramos modificar el STACK antes de que esto ocurra... ¡¡Éxito!!</small></span>
					
				</section>
				
				<section data-auto-animate data-transition="slide" data-background="#120066">
					<h3 > Breve introducción a nuestro "sistema de pruebas".</h3>
					<small>Sistemas reales con vulnerabilidades reales</small>
				</section>

				<section data-transition="fade" data-background="#120066">

					<section>
					<small><img src="res/nds.png"></small><br>
					<small>Nintendo DS - ARM7 y ARM9</small><br>
					<small>Año de lanzamiento: 2006. Precio actual: < 20€</small><br>
					<small>Seguridad: comprobación de firmas del código. <p class="fragment highlight-red" data-fragment-index="2" >No DEP/NX bit.</p></small>
					</section>

					<section>
						<small>También podemos buscar exploits de forma gratuita utilizando software libre y emuladores:</small><br><br>
						<ul>
							<li>emulador <a href="https://problemkaputt.de/gba.htm"> no$gba</a></li>
							<li>emulador DeSmune.</li>
						</ul>
						<br>+<br>
						<ul>
							<li><a href="https://ghidra-sre.org/">Ghidra</a></li>

						</ul>
					</section>


				</section>

				<section data-transition="fade" data-background="#120066">

					<section>
					<img class="stretch" src="res/3dsaqua.png"><br>
					<small>Nintendo 3DS - ARM9 y ARM11</small><br>
					<small>Año de lanzamiento: 2011. Precio actual: 20-40€</small><br>
					<small>Seguridad: CPU segura dedicada. Sistema Operativo con varios niveles de privilegio. <p class="fragment highlight-green" data-fragment-index="2" >Protección DEP/NX bit.</p></small>
					</section>

					<section>
						<small>También podemos buscar exploits de forma gratuita utilizando software libre y emuladores:</small><br><br>
						<ul>
							<li><a href="https://citra-emu.org/"> emulador citra</a></li>
						</ul>
						<br>+<br>
						<ul>
							<li><a href="https://ghidra-sre.org/">Ghidra</a></li>
						</ul>
						<br>+<br>
						<ul>
							<li><a href="https://gist.github.com/LiquidFenrir/d110f3e7755ffbe82672eda49ae21af2">GDB</a></li>
						</ul>
					</section>

				</section>


				<section data-auto-animate data-transition="fade" data-background="#660036">
					<h2>Stack Buffer Overflow</h2>
					<small>(*sin NX)</small>
					<br><br>
					<p>
						¿Cómo puede llegar un valor <strong>malicioso</strong> llegar al stack?.
					</p>

					<div style="position:relative; width:640px; height:480px; margin:0 auto;">
						<p class="fragment fade-in" data-fragment-index="0"><small>
							¿Y si pudiésemos sobreescribir valores del stack de forma no intencionada?
						</small></p>
					</div>
				</section>

				<section data-auto-animate data-transition="fade" data-background="#660036">
					<h2>Stack Buffer Overflow</h2>
					<small>(*sin NX)</small><br>

					<img class="stretch" src="res/stackLayout_b.png">

				</section>


				<section data-auto-animate data-transition="fade" data-background="#660036">
					<h2>Stack Buffer Overflow</h2>
					<small>(*sin NX)</small><br>

					<p>¿Unos fifitas?</p>
					<div style="position:relative; width:480px; height:480px; margin:0 auto;">
						<img class="fragment fade-in-then-out" data-fragment-index="0"  src="res/fifa06.jpg" style="position:absolute;top:0;left:0;" />
						<img class="fragment fade-in-then-out" data-fragment-index="1"  src="res/fifa07.jpg" style="position:absolute;top:0;left:0;" />
						<img class="fragment fade-in-then-out" data-fragment-index="2"  src="res/fifa09.jpg" style="position:absolute;top:0;left:0;" />
						<img class="fragment fade-in-then-out" data-fragment-index="3"  src="res/fifa10.jpg" style="position:absolute;top:0;left:0;" />
						<img class="fragment fade-in-then-out" data-fragment-index="4"  src="res/fifa11.jpg" style="position:absolute;top:0;left:0;" />
						<p class="fragment fade-in"><strong>TODOS</strong> los juegos de FIFA para Nintendo DS tienen al menos una vulnerabilidad de este tipo.</p>
					</div>
					
				</section>

				<section data-auto-animate data-transition="fade" data-background="#660036">
					<h2>Stack Buffer Overflow</h2>
					<small>(*sin NX)</small>

					<section>
						<p class="fragment fade-in" data-fragment-index="0">
							FIFA08: El stack overflow se encuentra en el nombre de perfil de la partida guardada:
						</p>
					</section>

					<section>
						<br><br>
						<img class="stretch" src="res/hxd1.png" height="45%" width="45%"><br>
						<small>Una partida guardada normal.</small>
					</section>

					<section>
						<br><br>
						<img class="stretch" src="res/hxd2.png">
						<small>Una partida modificada con una cadena de texto mayor.</small>
					</section>

					<section>
						<br><br><br><br><small>¡Hemos sobrescrito el valor de LR en el stack y este se ha propagado hasta el PC!</small>
						<div style="position:relative; width:580px; height:580px; margin:0 auto;">
							<img class="fragment fade-in-then-out" data-fragment-index="0" src="res/hxd5.png" style="position:absolute;top:0;left:0;">
							<img class="fragment fade-in" data-fragment-index="1" src="res/hxd4.png" style="position:absolute;top:0;left:0;">
						</div>
						
					</section>
				
					<section>
						<br><br>
						<img class="stretch" src="res/hxd3.png" height="45%" width="45%"><br>
						<small>Localizamos que 'AAAA's llegan al PC. Reemplazamos con la dirección donde reside nuestro código.</small>
					</section>

					<section>
						<br><br>
						<img class="stretch" src="res/hxd6.png" height="45%" width="45%"><br>
						<small>La imagen completa. Código y relleno.</small>
					</section>

					<section>
						<br><br>
						<img class="stretch" src="res/exploit1.PNG" height="45%" width="45%"><br>
						<small>De esa forma, logramos ejecutar código no firmado por Nintendo.</small>
					</section>

					<section>
						<br><br>
						<img class="stretch" src="res/realhw.jpg" height="45%" width="45%"><br>
						<small>Por supuesto, funciona en el hardware de verdad ;).</small>
					</section>

				</section>

				<section data-auto-animate data-transition="fade" data-background="#660036">
					<h2>Stack Buffer Overflow en C</h2>
					
					Existen funciones estándard de C que son vulnerables o causan este tipo de problemas con la memoria:

					<ul>
						<li>scanf()</li>
						<li>gets()</li>
						<li>strcpy()</li>
						<li>memcpy()</li>
					</ul><br>

					Estas funciones están consideradas obsoletas pero se siguen utilizando.
				</section>

				<section data-auto-animate data-transition="fade" data-background="#660036">
					<h2>Stack Buffer Overflow en C</h2>
					
					Cualquier función hecha por un programador y que trabaje con arrays o buffers, puede ser vulnerable.


				</section>

				<section data-auto-animate data-transition="fade" data-background="#660036">
					<h2>Conclusiones: Stack Buffer Overflow</h2>
					<small>(*sin NX)</small><br>

					Si no existe ningún tipo de medida de protección contra ataques de corrupción de memoria, es trivial aprovechar un fallo y redirigir el flujo de ejecución a nuestro propio código.
					<ul>
						<li>Secure (co)processors --> baremetal</li>
					</ul>

				</section>


				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Stack Buffer Overflow + mitigaciones</h2>
					
					Por supuesto, la tecnología ha avanzado y tenemos medidas de seguridad para mitigar estos ataques.<br>
					NX(No eXecute) bit / DEP(Data Execution Prevention)


					<p class="fragment fade-in" data-fragment-index="0">
						No todas las zonas de la memoria pueden utilizarse para ejecutar código.

						<div style="position:relative" >
							<ul>
								<li class="fragment fade-in-then-out" data-fragment-index="1" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;">Si podemos escribir (rw-) en una página, no podremos ejecutar código de esa página.</li>
								<li class="fragment fade-in" data-fragment-index="2" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;">Si podemos ejecutar código (r-x) en una página, no podremos modificar sus contenidos.</li>
							</ul>
						</div>

						
					</p>

				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Stack Buffer Overflow + mitigaciones</h2>
					
					¿Cómo evadimos esta protección?<br>

				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Stack Buffer Overflow + mitigaciones</h2>
					
					ROP<br>
					<small>Return Oriented Programming</small>

				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Stack Buffer Overflow + mitigaciones</h2>
					
					ROP: un tipo de ataque de reutilización de código.<br>
					<small>¿No podemos inyectar nuestro propio payload? No problem: utilizaremos el código que ya existe en memoria</small>

				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Stack Buffer Overflow con DEP (ROP)</h2>
					<img class="stretch" src="res/ropchain.png" height="45%" width="45%"><br>
					<small>Imagen: <a href="https://www.researchgate.net/figure/Attack-using-return-oriented-programming-The-attacker-arranges-gadget-addresses-on-the_fig1_262291473">Per Larsen</a></small>
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Stack Buffer Overflow con DEP (ROP)</h2>
					<small>A cada una de esas piezas la llamaremos gadget. </small>
					<small>Al conjunto de todas estas piezas encadenadas lo conocemos como "rop chain" (cadena de gadgets). </small>
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Stack Buffer Overflow con DEP (ROP)</h2>
					Tutoriales Intel x86: <q cite>Los gadgets son piezas de código que acaban con una instrucción RETURN que ejecuta nuestro próximo gadget</q>
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Stack Buffer Overflow con DEP (ROP)</h2>
					La realidad en ARM: <q cite>Los gadgets son piezas de código que terminan con una instrucción que nos permite saltar a otro gadget <strong>en una dirección indicada por nosotros.</strong> </q>
					<p class="fragment highlight-red" data-fragment-index="0" >No existe la instrucción RETURN</p>
				</section>


				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Stack Buffer Overflow con DEP (ROP)</h2>
					<small>Ejemplos de instrucciones de retorno en ARM</small>	
						
						<pre data-id="code-animation"><code class="hljs" data-trim>
							pop {r0, r7, pc} //pop pc
							pop {r2, pc}     //pop pc
							pop {pc}         //pop pc
	
							pop {r4} @pop registro
							b r4     @Esto es JOP
						</code></pre>

						<br>
						La instrucción pop {lista de registros} extrae del <strong>STACK</strong> los valores y los copia a los registros indicados en la lista.
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Stack Buffer Overflow con DEP (ROP)</h2>
					<small>También podemos usar ROP para llamar directamente a funciones enteras que existan. También a syscalls (funciones del Sistema Operativo)</small>	
					<pre data-id="code-animation"><code class="hljs" data-trim>
						svc #7    //svcSleep()
						svc #0xB7 //svcCreateThread()
						...
					</code></pre>
					<small>SVC es la instrucción en ARM para hacer syscalls.</small>
						
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>1. Cómo obtener gadgets</h2>
						Existen 2 fuentes de obtención de gadgets:<br><br>
						<ul>
							<li>Archivos binarios de los programas (ELF, PE(.exe), etc)</li>
							<li>Volcados de memoria.</li>
						</ul>
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>1. Cómo obtener gadgets</h2>
					Archivos binarios de los programas (ELF, PE(.exe), etc)
						<ul>
							<li>Fácil</li>
							<li>Docenas de scripts.</li>
							<li>Variedad de motores de des-ensamblado</li>
							<li><a href="https://github.com/JonathanSalwan/ROPgadget">ROPGadget</a></li>
							<li><a href="http://ropshell.com/">ROPshell</a></li>
							<li><a href="https://scoding.de/ropper/">ROPPER</a></li>
						</ul>
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>1. Cómo obtener gadgets</h2>
					Volcados de memoria (o archivos raw).
						<ul>
							<li>Complejo</li>
							<li>Programas específicos para cada situación...</li>
							<li>...</li>
						</ul>
						<!--<p class="fragment">... Hasta hoy.</p>-->

				</section>

				<!--
				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Stack Buffer Overflow con DEP (ROP)</h2>
					<img src="res/memorywizard.png" ><br>
					<small> <a href="https://github.com/pedro-javierf/MemWizard">MemWizard</a></small><br>
					<small>El primer buscador de gadgets con interfaz gráfica.</small>
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Stack Buffer Overflow con DEP (ROP)</h2>
					<img class="stretch" src="res/memorywizard2.png" ><br>
					<small> Interfaz de la herramienta.</small>
				</section>-->

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Preguntas Frequentes</h2>
					<h3>1. ¿Podemos hacer un exploit entero solo con ROP?</h3><br>
					<h3>2. ¿Hay vida más allá de ROP?</h3>
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Respuestas</h2>
					<h3>1. ¿Podemos hacer un exploit entero solo con ROP?</h3><br>
					<h4>Sí, aunque depende del objetivo de nuestro exploit.</h3>
						<ul>
							<li>Descargar un ejecutable y decirle al SO que lo lance: OK</li>
							<li>Exfiltrar algún archivo mediante la red: OK</li>
							<li>Cargar código dinámicamente: X</li>
						</ul>
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					<h2>Respuestas</h2>
					<h3>2. ¿Hay vida más allá de ROP?</h3><br>
					<h4>Sí. Cómo librarse de ROP.</h3>


						<div style="position:relative" >
							<ul>
								<li class="fragment fade-in-then-out" data-fragment-index="1" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;">Podemos utilizar una función del sistema operativo para modificar las páginas de memoria:</li>
								<li class="fragment fade-in-then-out" data-fragment-index="2" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;">Podemos convertir una página que previamente era rw- en una página r-x</li>
								<li class="fragment fade-in" data-fragment-index="3" style="position:absolute; margin-left: auto; margin-right: auto; left: 0; right: 0;">Después de llamar a la función, cualquier código que estuviese en esa página pasará a ser ejecutable directamente.</li>
							</ul>
						</div>
						<br><br><br>
						<pre data-id="code-animation"><code class="hljs" data-trim>
							svc 0x70    // ControlProcessMemory
						</code></pre>
						<!--
						<ul>
							<li>Podemos convertir una página que previamente era rw- en una página r-x</li>
							<li>Después de llamar a la función, cualquier código que estuviese en esa página pasará a ser ejecutable directamente.</li>
						</ul>-->
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					Ejemplo:<a href="https://github.com/fincs/new-hbmenu"> lanzador de aplicaciones caseras para Nintendo 3DS</a>
					<br><img class="stretch" src="res/hbmenu.png">
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					Ejemplo de vulnerabilidad en Nintendo 3DS:<br><a href="https://github.com/yellows8/oot3dhax"> Ocarina Of Time 3D</a>
					<br><img class="stretch" src="res/ocarina.jpeg">
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					rop_gadgets.h
					<pre data-id="code-animation"><code class="hljs" data-trim>
						#define ROP_POPPC  0x00150360
						#define POP_R1PC   0x00368fbc
						#define POP_R3PC   0x00145148
						#define POP_R2R6PC 0x0044820c
						#define POP_R4LR_BXR1   0x00238710
						#define svcGetProcessId 0x0030794c
						#define SRV_GETSERVICEHANDLE 0x0030dde8
						#define IFile_Open 0x0030d580
						#define THROWFATALERR 0x003351b4
					</code></pre>
					
				</section>

				<section data-auto-animate data-transition="fade" data-background="#006664">
					rop_payload.s
				<pre data-id="code-animation"><code class="hljs" data-trim>
					.word ROP_MOV_R3_4_JUNKTOR0		@ ------------ Color the screen so users know something good is happening 
						.word GARBAGE			@ 	r4
						.word GARBAGE	    		@ 	r5
						.word GARBAGE	    		@ 	r6
						.word GARBAGE	    		@ 	r7
						.word GARBAGE	    		@ 	r8
					.word POP_R0PC          		@
						.word GSPGPU_SERVHANDLEADR	@ 	GSGPU Handle already present in memory
					.word POP_R1PC				@
						.word HWREGS_ADDR      		@ 	Register address for bottom screen coloring
					.word POP_R2PC          		@
						.word MAGENTA_ADDR  		@	Existing location of magenta color 
					.word GSPGPU_WriteHWRegs		@   	GSPGPU_WriteHWRegs(&GSPHandle, HwRegsAddress, &MagentaAddr, size=4)
						.word GARBAGE	    		@ 	r4
						.word GARBAGE	    		@ 	r5
						.word GARBAGE			@ 	r6	
					.word ROP_MOV_R1_0			@ ------------ Wait a little bit to make sure export completes before the crash
						.word GARBAGE			@	r4
					.word POP_R0PC				@
						.word 0xFFFFFFFF		@	r0 ... r1 is zeroed above
					.word svcSleepThread			@   	svcSleepThread(u64 0x00000000FFFFFFFF) this is about 4 seconds.
				</code></pre>
			</section>

			<section data-auto-animate data-transition="fade" data-background="#006664">
				Otro ejemplo:<a href="https://fundacion-sadosky.github.io/guia-escritura-exploits/esoteric/6-ret2libc.html"> return to libc (ret2libc)</a>
				Solo aplicable en sistemas Linux.<br><br>
				Consiste en llamar a la función <i>system()</i> de la biblioteca <i>libc</i> con sólo un parámetro, "/bin/sh".
			</section>

			<section data-auto-animate data-transition="fade" data-background="#006664">
				<h2>Conclusiones: ROP</h2>
				<ul>
					<li>Técnica muy poderosa para desarrollar exploits</li>
					<li>Permite hacer <b>casi</b> de todo.</li>
				</ul>

			</section>



				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>ASLR</h2>
					
					Medida de protección que inutiliza ROP casi al completo.<br>
					<p class="fragment">ASLR = "Address Space Layout Randomization"</p>
					<br>

					<q>Cada vez que arranques la CPU vamos a organizar de forma diferente y aleatoria la memoria, ¡para que no sepas dónde están tus gadgets!</q>

				</section>


				<section data-background="#ffffff">
					<img src="res/aslr.png" ><br>
					Imagen: 
					<a href="https://arstechnica.com/information-technology/2012/03/new-internet-explorer-10-memory-protection-features-not-just-for-internet-explorer/#:~:text=ASLR%20in%20action:%20each%20time%20you%20boot,%20DLLs%20get%20loaded"> ARS Technica</a>
					
				</section>

				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>ASLR</h2>
					
					Nuestra cadena ROP no funcionará porque cada vez la localización de nuestros gadgets será distinta.<br>

					Y no solo será distinta, sino que será aleatoria, es decir, no podemos predecir dónde estarán.

				</section>

				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>ASLR</h2>
					
					<ul>
						<li>Una de las mitigaciones más efectivas.</li>
						<li>Hace que una vulnerabilidad cómo las anteriores sea inútil por si misma.</li>
					</ul>

					<p class="fragment">pero ...</p>

					

				</section>

				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>ASLR</h2>
					
					* Existen <b>otros tipos</b> de vulnerabilidades que podemos usar para vencer al ASLR.

				</section>

				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>leaking pointer / leaking address</h2>
					
					Errores o vulnerabilidades que nos permiten conocer la dirección en memoria de una variable, por ejemplo.

					<pre data-id="code-animation"><code class="hljs" data-trim>
						int a = 7;                   //Variable llamada a
						printf("Dirección: %p", &a); //Muestra la dirección en memoria de a
					</code></pre>

					<pre data-id="code-animation"><code class="hljs" data-trim>
						Dirección: 0xFFFF8000 000A000B
					</code></pre>
					


				</section>

				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>leaking pointer / leaking address</h2>
					
					¿Y si aprovechamos esta función de C de forma maliciosa?<br>
					Veamos el siguiente código:
					<pre data-id="code-animation"><code class="hljs" data-trim>
						char userinput[100];
						gets(userinput);  //El usuario introduce datos
						printf(userinput);//No comprobamos ese input
					</code></pre>
					

				</section>

				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>leaking pointer / leaking address</h2>
					
					La entrada del usuario se envía a <i>printf()</i> sin ser verificada.<br>
					<a href="http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf">Vulnerabilidad de cadenas de texto con formato</a>
					<br>
					 
					<p class="fragment">
						

						<small>Ejemplo: el argumento %s leerá el contenido que haya en la dirección indicada por el elemento en la cima del stack.</small>
					</p>
					<pre data-id="code-animation"><code class="hljs" data-trim>
						printf("%s");
					</code></pre>
					
					

				</section>

				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>ASLR + leaking pointer / leaking address</h2>
					
					Combinamos un stack overflow + una vulnerabilidad que nos permita descubrir cuál es la estructura de la memoria y la posición de sus elementos.
					<br><br>
					<p class="fragment">Veámos el puzle completo con detenimiento: </p>


				</section>

				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>Evadir ASLR: Pasos</h2>
					
					<small>
					<ol>
						<li> Obtener la dirección estática de una variable en el binario</li>
						<li> Obtener la dirección en memoria mediante la filtración (leaked address)</li>
						<li> Calcular la diferencia entre una y otra (slide)</li>
						<li> Sumar/Restar esa diferencia a la dirección de los gadgets</li>
						<li> Lanzar la cadena, ahora que está adaptada.</li>
					</ol>
				</small>


				</section>

				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>ASLR + memory leaks</h2>
					También existen otros métodos...<br>
					<ul>
						<li>Pointer leak</li>
						<li>Módulos sin ASLR</li>
						<li>Implementación débil de ASLR</li>
					</ul><br>
				</section>

				<section data-background="#465396">
					
					<div style="position: absolute; width: 40%; right: 0; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.9); color: #fff; padding: 20px; font-size: 20px; text-align: left;">
						<h2>ASLR bypass</h2>
						<p>Ejemplo de aplicación/código vulnerable</p>
					</div>
					<script src="https://gist.github.com/pedro-javierf/ebf3781cdc9209492d952471feed5787.js"></script>

					


				</section>

				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>ASLR bypass</h2>
					
					Vamos a compilarlo y ejecutarlo en una Raspberry Pi 3, con procesador ARMv8:

					<pre data-id="code-animation"><code class="hljs" data-trim>
						gcc overflow.c -o overflow -fno-stack-protector -pie -fPIE
					</code></pre>
					NOTA: Utilizando -fno-stack-protector desactivamos la protección stack-canary, que no trataremos en esta ocasión.
				</section>

				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>ASLR: CONCLUSIONES</h2>
					También podemos evadir ASLR.<br>
					Por ello nacen...:<br>
					<ul>
						<li>Stack Cookies / Stack Canary</li>
						<li>SEHOP</li>
						<li>Null Page Protection</li>
						<li>...</li>
					</ul>

				</section>

				<section data-auto-animate data-transition="fade" data-background="#465396">
					<h2>ASLR: CONCLUSIONES</h2>
					
					Además, existen vulnerabilidades no relacionadas con el stack:<br>
					
					<a href="https://lmgtfy.com/?q=heap+overflow">Heap Overflows</a> <br>
					<a href="https://lmgtfy.com/?q=heap+overflow">Ataques mediante SEH (Structured Exception Handler)(Windows)</a> <br>

				</section>

				<section style="text-align: left;">
					<h1>THE END</h1>
					<p>
						- <a href="https://pedro-javierf.github.io/talks/c1b3rwallacademy2020">Diapositivas & recursos</a> <br>
						- <a href="https://github.com/pedro-javierf">Código</a>
					</p>
				</section>

			</div>

		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/zoom/zoom.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/search/search.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>

			// Also available as an ES module, see:
			// https://revealjs.com/initialization/
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
			});

		</script>

	</body>
</html>
